package binsrch

type Coordinate interface {
	~int | ~int8 | ~int32 | ~int64
}

type Point[C Coordinate] struct {
	{{range .Coords}}
	{{.Name}} C
	{{end}}
}

type Points[C Coordinate] []Point[C]

{{range .Coords}}
{{ $coord := . }} 
func (points Points[C]) Where{{.Name}}(target C) (Points[C], bool) {
  size := len(points)

  if size == 0 {
    return nil, false
  }

  {{range $.Bounds}}
  ch{{.Name}} := make(chan int)

  go func() {
    ch{{.Name}} <- points.Find{{.Name}}{{$coord.Name}}(target, 0, size-1)
  }()

  val{{.Name}} := <- ch{{.Name}}
  close(ch{{.Name}})

  if val{{.Name}} == -1 {
    return nil, false
  }

  {{end}}
  return points[val{{$.Lower.Name}} : val{{$.Upper.Name}} + 1], true
}
{{end}}

{{range .Coords}}
{{ $coord := . }}
{{range $.Bounds}}
func (points Points[C]) Find{{.Name}}{{$coord.Name}}(target C, lower, upper int) int {
  windowSize := (upper - lower) + 1

  if windowSize == 1 {

  last := points[lower].{{$coord.Name}}

    if last == target {
      return lower
    }

    return -1
  }

  jump := lower + windowSize/2

  test := points[jump].{{$coord.Name}}

  var l, u int
  if test == target {
    look := jump + {{.Polarity}}

    if look < 0 || look == len(points) {
      return jump
    }

    if points[look].{{$coord.Name}} != target {
      return jump
    }

    {{if .IsLower}}
    l = lower
    u = jump + {{.Polarity}}
    {{else}}
    l = jump + {{.Polarity}}
    u = upper
    {{end}}
  }

  if test > target {

    l = lower
    u = jump - 1

  } else {

    l = jump + 1
    u = upper
  }

  return points.Find{{.Name}}{{$coord.Name}}(target, l, u)
}
{{end}}
{{end}}
